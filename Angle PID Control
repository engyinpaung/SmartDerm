from simple_pid import PID
import time
import matplotlib.pyplot as plt

run = True 
class pressure: 
    def__init__(self): 
#Insert Bluetooth module retrieving data from sensors (From Vinith) 
    self.pressure_mat = #pressure matrix 

#Insert Raspberry Pi  


#Define Smartderm Class
class smartderm:
    def __init__(self):
        self.angle = 0 #Need data from accelerometer 
        self.pressure = [] #Need data from FSR 
    def update(self, control,dt):
        try: 
            if control_output > 0: #Why greater than 0? Find out 
                self.angle += 0.5*dt #Revise this with Smartderm team
                #Insert relay switch code 
            else:
                self.angle -= 30*dt
        except:
            pass
        return self.angle
class pid_ctl(PID): 
    machine = True
    Kp_angle = 10
    Ki_angle = 10
    Kd_angle = 10
    sp_angle = 30
    Kp_pressure = 10
    Ki_pressure = 10
    Kd_pressure = 10
    sp_pressure = 30
    def __init__(self,input,control_var) 
        if control_var == 'angle': 
            super().__init__(Kp='Kp_angle',Ki='Ki_angle',Kd='Kd_angle',setpoint='sp_angle')
            self.input = #measurements from accelerometer 
        elif control_var == 'pressure': 
            super().__init__(Kp='Kp_pressure',Ki='Ki_pressure',Kd='Kd_pressure',setpoint='sp_pressure')
            self.input = #measurements from FSR 
        else: 
            return None 
    def pid_plot():
        current_time = time.time() 
        t += [current_time - start_time] #create list for time variable
        omega += [control_var] #create list for ctl variable
        sp_tuple += [setpoint] #create setpoint constant
        last_time = current_time
        # Visualization of Output Results
        plt.plot(t, sp_tuple, label='target')
        plt.plot(t, omega, label='PID')
        plt.xlabel('time')
        plt.ylabel(control_var)
        plt.legend()
        plt.show()
    def init_pressure(self):
        #Obtain pressure matrix and find the gradient of matrix
        #If gradient >> 0, interrupt control loop sequence and modulate pressure (patient returns to supine position and then turn opposite way) 
        #If gradient ~= 0, pass 
if __name__ == '__main__':
    input = smartderm()
    time_delta = start.time() + 60 * 15 #1 hour spent in each orientation 
    while run = True:
        control = pid_ctl(input,control_var)
        # Compute new output from the PID according to the systems current value
        output = control(input)
        # Feed the PID output to the system and get its current value
        output_update = controlled_system.update(output)
        while start_time - current_time < time_delta: #runs for 1 hour
            pid_setpoint = setpoint[1]
            sys_pid = pid_loop(pid_setpoint)

   
